#include <stdio.h>
#include <mach.h>

#define i860	1	/* Just for pretend... */
#undef mc68000
#include "sys/types.h"
#include "ND/NDreg.h"

#include "vm/vm_param.h"
#include "vm/vm_prot.h"

#include "i860/vm_types.h"

unsigned long	_slot_id_ = 0;	// Slot ID is ORed into phys addresses on boot.


#define VRAM_START	(vm_offset_t)ND_BASE_VRAM
#define VRAM_END	(vm_offset_t)ND_END_VRAM
#define DRAM_LO_START	(vm_offset_t)ND_BASE_DRAM
#define DRAM_LO_END	(vm_offset_t)ND_BASE_DRAM+0x00400000
#define DRAM_HI_START	(vm_offset_t)DRAM_LO_END
#define DRAM_HI_END	(vm_offset_t)ND_START_UNCACHEABLE_DRAM
#define UNCACHED_START	DRAM_HI_END
#define UNCACHED_END	(vm_offset_t)0xFFFFF000


#define DEBUG	0

unsigned long * kpde;	/* Initial kernel dirbase value */
unsigned long * transparent_DRAM;

vm_size_t	page_size;
vm_size_t	page_mask;
int		page_shift;


/*
 * Set the logical page size.
 * Currently, the i860 uses a 4 Kbyte page and the host uses an 8 Kbyte page.
 */
 static void
vm_set_page_size()
{
	int i;
	page_size = ND_PAGE_SIZE;	/* Tunable parameter. */
	page_mask = page_size - 1;
	
	page_shift = 0;
	for( i = page_size; (i & 1) == 0; i >>= 1 )
		++page_shift;
}

/* PTE mode bits for assorted areas of memory. */
#define PTE_CSR		V_UD		/* Hardware CSR page */
#define PTE_VRAM	V_D		/* The frame buffer */
#define PTE_DATA	V_D		/* Mode for misc processor data */
#define PTE_UNCACHED_DATA	V_UD	/* Assorted data which MUST not be cached */
#define PTE_TEXT	V_D		/* Mode for executable code */
#define PTE_PTES	V_UD		/* Mode for pages of PTEs */
#define PTE_KPDE	V_D		/* Mode for page directory entries. */



map_range( vm_address_t vstart, vm_address_t pstart, vm_size_t size, int mode )
{
	vm_offset_t poff, voff;
	unsigned long *kpte;
	
	pstart = trunc_page(pstart);
	poff = pstart;
	voff = trunc_page(vstart);
	size = round_page(size);
	
	while ( poff < (pstart + size) )
	{
		if( (kpte = (unsigned long *)kpde[pdenum(voff)]) == (unsigned long *)0)
		{
			kpte = (unsigned long *) malloc(i860_PGBYTES);
			bzero( (char *) kpte, i860_PGBYTES );
			/* Grow the page directory */
			kpde[pdenum(voff)] = ((unsigned long)kpte); 
		}
		kpte[ptenum(voff)] = trunc_page(poff) | mode;
#if DEBUG
printf( "vaddr 0x%08x: 	paddr 0x%08x, pte %d, pde %d, (0x%08x)\n",
	voff, poff, ptenum(voff), pdenum(voff), kpte[ptenum(voff)] );
#endif
		voff += i860_PGBYTES;
		poff += i860_PGBYTES;
	}
}


main()
{
	vm_set_page_size();
	
	kpde = (unsigned long *)malloc(i860_PGBYTES);
	bzero( (char *) kpde, i860_PGBYTES );
	
	/* Shadow map 1st bank of DRAM, initially uncacheable
	 * This gets used to transparently map the kernel during boot.
	 */
	map_range( (vm_address_t)0, (vm_address_t)PADDR_DRAM,
			(vm_size_t)0x00400000, PTE_UNCACHED_DATA );
	transparent_DRAM = (unsigned long *)kpde[pdenum(0)];
	kpde[pdenum(0)] = 0;

	/* Map all of possible DRAM, initially uncacheable */
	map_range( (vm_address_t)ADDR_DRAM, (vm_address_t)PADDR_DRAM,
			(vm_size_t)PADDR_DRAM_SIZE, PTE_UNCACHED_DATA );

	/* Map in the Memory Controller, 1:1 mapping */
	map_range( (vm_address_t)PADDR_MC, (vm_address_t)PADDR_MC,
			(vm_size_t)PADDR_MC_SIZE, PTE_CSR );

	/* Map in the trap vector page */
	map_range( 	(vm_address_t)ADDR_TRAP_VECTOR,
			(vm_address_t)PADDR_TRAP_VECTOR_PAGE,
			(vm_size_t)i860_PGBYTES, PTE_UNCACHED_DATA );
	
	output();
}

/*
 * Emit the big page aligned pieces of low memory data for the i860 kernel.
 *
 * This includes the kernel stack, the 2 pages used by flush() and bootflush(),
 * and an initial page table for use during bootstrap.
 */
output()
{
	long now;
	extern char *ctime();
	
	time( &now );
	printf("//\n//\tGenerated by build_pte.\n//\n//\tDO NOT EDIT THIS FILE\n//\n");
	printf("//\tBuilt %s//\n", ctime( &now ) );

	printf("\t.data\n");
	printf("\t_sdata:\t.globl _sdata\t// Marks start of all data.\n");
	printf("\t.blkb\t%d\t// Space for task 0 stack.\n", i860_PGBYTES );
	printf("\tdf_stack:\t.globl df_stack\n");
	printf("\tintstack:\t.globl intstack\t// top of task 0 stack\n\n");


	printf("\t_bad:\t.globl _bad\n");
	printf("\t.blkb	8192\t// Trashable 8K band for flush(), bootflush()\n");

	dump_tables();
}

dump_page( unsigned long * addr )
{
	int i;
	for ( i = 0; i < (i860_PGBYTES / sizeof (unsigned long)); i += 4 )
	{
		printf( "\t.long\t0x%08x, ", addr[i] );
		printf( "0x%08x, ", addr[i+1] );
		printf( "0x%08x, ", addr[i+2] );
		printf( "0x%08x\n", addr[i+3] );
	}
}

/*
 * Dump low memory data pages for bootstrap page table in i860 assembler format.
 */
dump_tables()
{
	int i;
	vm_offset_t off;
	
	printf( "\n__start_page_tables_:\t.globl __start_page_tables_\n" );
	for ( i = 0; i < (i860_PGBYTES / sizeof (unsigned long)); ++i )
	{
		if ( kpde[i] != 0 )
		{
			printf( "\nkpte%d:\t// Vaddr range 0x%08x - 0x%08x\n",
				i, pdetova(i), pdetova(i) + (1 << PDESHIFT) );
			dump_page( (unsigned long *)kpde[i] );
		}
	}

	//	Dump a page which will be used to transparently map the kernel
	printf("transparent_DRAM:\t.globl transparent_DRAM\n");
	dump_page( transparent_DRAM );

	printf( "\nkpde:\t.globl kpde	// Kernel page directory\n" );
	
	i = 0;
	while (  i < (i860_PGBYTES / sizeof (unsigned long)) )
	{
		if ( kpde[i] == 0 )
			printf( "\t.long\t0x00000000,\t" );
		else
			printf( "\t.long\tkpte%d+0x%x,\t", i, PTE_KPDE );
		++i;

		if ( kpde[i] == 0 )
			printf( "0x00000000,\t" );
		else
			printf( "kpte%d+0x%x,\t", i, PTE_KPDE );
		++i;
		
		if ( kpde[i] == 0 )
			printf( "0x00000000,\t" );
		else
			printf( "kpte%d+0x%x,\t", i, PTE_KPDE );
		++i;
		
		if ( kpde[i] == 0 )
			printf( "0x00000000\n" );
		else
			printf( "kpte%d+0x%x\n", i, PTE_KPDE );
		++i;
	}
	printf( "\n__end_page_tables_:\t.globl __end_page_tables_\n" );
}


